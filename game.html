<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Trop d'enfants, partout... — Meridian Game Jam Entry</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a2a1a;
  color: #e0e0e0;
  font-family: 'Courier New', monospace;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
}
#game-container {
  width: 100vw;
  height: 100vh;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
canvas { image-rendering: pixelated; }
#ui-overlay {
  position: absolute;
  top: 10px;
  left: 10px;
  font-size: 14px;
  color: #88cc44;
  pointer-events: none;
  text-shadow: 1px 1px 2px #000;
}
#text-area {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  text-align: center;
  max-width: 600px;
  font-size: 16px;
  line-height: 1.6;
  color: #cca;
  text-shadow: 1px 1px 2px #000;
  pointer-events: none;
}
.title-screen { text-align: center; }
.title-screen h1 { font-size: 2.2em; color: #ccaa44; margin-bottom: 0.3em; }
.title-screen .subtitle { color: #888; font-size: 0.9em; margin-bottom: 0.5em; font-style: italic; }
.title-screen p { color: #666; margin-bottom: 0.8em; }
.title-screen .start-btn {
  color: #ccaa44;
  cursor: pointer;
  font-size: 1.2em;
  animation: pulse 2s ease-in-out infinite;
}
.title-screen .controls { color: #555; font-size: 0.75em; margin-top: 1em; line-height: 1.8; }
@keyframes pulse {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 1; }
}
#credit {
  position: absolute;
  bottom: 5px;
  right: 10px;
  font-size: 10px;
  color: #333;
}
</style>
</head>
<body>
<div id="game-container">
  <div class="title-screen" id="title">
    <h1>Trop d'enfants, partout...</h1>
    <p class="subtitle">too many children, everywhere...</p>
    <p>a game by Meridian</p>
    <p class="start-btn" onclick="startGame()">[ click to begin ]</p>
    <div class="controls">
      Arrow keys / WASD to move<br>
      SPACE to shoo children away (costs energy)<br>
      Reach the colored zones to drop off clinging children
    </div>
  </div>
  <canvas id="canvas" style="display:none;"></canvas>
  <div id="ui-overlay" style="display:none;"></div>
  <div id="text-area" style="display:none;"></div>
</div>
<div id="credit">Meridian / KometzRobot | AI Game Jam Feb 22, 2026 | Theme: Trop d'enfants, partout...</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const ui = document.getElementById('ui-overlay');
const textArea = document.getElementById('text-area');

function resizeCanvas() {
  canvas.width = Math.min(800, window.innerWidth);
  canvas.height = Math.min(600, window.innerHeight - 20);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let state = { phase: 'title', tick: 0, score: 0 };
const keys = {};
document.addEventListener('keydown', e => { keys[e.key] = true; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault(); });
document.addEventListener('keyup', e => { keys[e.key] = false; });

// === PARTICLE SYSTEM ===
let particles = [];
let screenShake = 0;

function spawnParticles(x, y, color, count, speed) {
  for (let i = 0; i < (count || 5); i++) {
    let angle = Math.random() * Math.PI * 2;
    let spd = (speed || 3) * (0.5 + Math.random());
    particles.push({
      x, y, dx: Math.cos(angle) * spd, dy: Math.sin(angle) * spd,
      life: 20 + Math.random() * 15, maxLife: 35, size: 2 + Math.random() * 3,
      color: color || '#ccaa44'
    });
  }
}
function shakeScreen(amount) { screenShake = Math.max(screenShake, amount || 4); }

function updateParticles() {
  particles.forEach(p => { p.x += p.dx; p.y += p.dy; p.dy += 0.04; p.life--; p.dx *= 0.97; });
  particles = particles.filter(p => p.life > 0);
  if (screenShake > 0) screenShake *= 0.85;
  if (screenShake < 0.3) screenShake = 0;
}

function drawParticles() {
  particles.forEach(p => {
    let alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// === GAME STATE ===
const PLAYER_BASE_SPEED = 3.2;
const SHOO_RADIUS = 80;
const SHOO_COST = 15;
const MAX_CLINGING = 5;
const DROP_ZONE_RADIUS = 40;

let player = { x: 400, y: 300, energy: 100, maxEnergy: 100 };
let children = [];
let clinging = 0;
let dropZones = [];
let childrenDeposited = 0;
let survivalTime = 0;
let alive = true;
let shooCooldown = 0;
let spawnRate = 0.015;
let waveTimer = 0;
let messages = [];
let highScore = 0;

const CHILD_COLORS = ['#ff6666', '#66aaff', '#ffcc44', '#ff88cc', '#88ff88', '#cc88ff', '#ffaa66', '#66ffcc'];

function makeChild(x, y) {
  return {
    x, y,
    dx: (Math.random() - 0.5) * 2,
    dy: (Math.random() - 0.5) * 2,
    size: 6 + Math.random() * 4,
    color: CHILD_COLORS[Math.floor(Math.random() * CHILD_COLORS.length)],
    state: 'wander',
    wanderTimer: Math.random() * 120,
    bobble: Math.random() * Math.PI * 2,
    speed: 1.2 * (0.7 + Math.random() * 0.6),
    chaseChance: 0.3 + Math.random() * 0.4,
  };
}

function initGame() {
  player.x = canvas.width / 2;
  player.y = canvas.height / 2;
  player.energy = 100;
  children = [];
  clinging = 0;
  childrenDeposited = 0;
  survivalTime = 0;
  alive = true;
  shooCooldown = 0;
  spawnRate = 0.015;
  waveTimer = 0;
  messages = [];
  particles = [];

  dropZones = [
    { x: 80, y: 80, color: '#44aa88', label: 'bac a sable' },
    { x: canvas.width - 80, y: 80, color: '#aa8844', label: 'toboggan' },
    { x: 80, y: canvas.height - 80, color: '#8844aa', label: 'balancoire' },
    { x: canvas.width - 80, y: canvas.height - 80, color: '#aa4488', label: 'tourniquet' },
  ];

  for (let i = 0; i < 5; i++) spawnChild();
}

function spawnChild() {
  let side = Math.floor(Math.random() * 4);
  let x, y;
  if (side === 0) { x = -10; y = Math.random() * canvas.height; }
  else if (side === 1) { x = canvas.width + 10; y = Math.random() * canvas.height; }
  else if (side === 2) { x = Math.random() * canvas.width; y = -10; }
  else { x = Math.random() * canvas.width; y = canvas.height + 10; }
  children.push(makeChild(x, y));
}

function addMessage(text, duration) {
  messages.push({ text, life: duration || 90, maxLife: duration || 90 });
}

function dist(a, b) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

function updateGame() {
  if (!alive) return;
  survivalTime++;
  state.score = Math.floor(survivalTime / 60);

  // Player movement — slower with more clinging children
  let speed = PLAYER_BASE_SPEED - clinging * 0.4;
  if (speed < 0.8) speed = 0.8;
  let mx = 0, my = 0;
  if (keys['ArrowLeft'] || keys['a']) mx -= 1;
  if (keys['ArrowRight'] || keys['d']) mx += 1;
  if (keys['ArrowUp'] || keys['w']) my -= 1;
  if (keys['ArrowDown'] || keys['s']) my += 1;
  if (mx && my) { mx *= 0.707; my *= 0.707; }
  player.x += mx * speed;
  player.y += my * speed;
  player.x = Math.max(12, Math.min(canvas.width - 12, player.x));
  player.y = Math.max(12, Math.min(canvas.height - 12, player.y));

  // Energy regen
  player.energy = Math.min(player.maxEnergy, player.energy + 0.05);

  // Shoo mechanic
  shooCooldown = Math.max(0, shooCooldown - 1);
  if (keys[' '] && shooCooldown <= 0 && player.energy >= SHOO_COST) {
    player.energy -= SHOO_COST;
    shooCooldown = 30;
    shakeScreen(3);
    spawnParticles(player.x, player.y, '#ffcc44', 12, 4);
    addMessage('SHOO!', 30);
    children.forEach(c => {
      if (c.state === 'clinging') {
        if (dist(player, c) < SHOO_RADIUS * 1.5) {
          c.state = 'fleeing';
          let angle = Math.atan2(c.y - player.y, c.x - player.x);
          c.dx = Math.cos(angle) * 5;
          c.dy = Math.sin(angle) * 5;
          c.wanderTimer = 90;
          clinging--;
          spawnParticles(c.x, c.y, c.color, 5, 3);
        }
      } else if (c.state === 'chase' || c.state === 'wander') {
        if (dist(player, c) < SHOO_RADIUS) {
          c.state = 'fleeing';
          let angle = Math.atan2(c.y - player.y, c.x - player.x);
          c.dx = Math.cos(angle) * 4;
          c.dy = Math.sin(angle) * 4;
          c.wanderTimer = 60;
        }
      }
    });
  }

  // Spawn rate increases over time
  spawnRate = 0.015 + survivalTime * 0.000008;
  waveTimer++;
  if (waveTimer > 600 && Math.random() < 0.005) {
    let count = 3 + Math.floor(survivalTime / 300);
    for (let i = 0; i < count; i++) spawnChild();
    addMessage('une vague d\'enfants!', 60);
    shakeScreen(4);
    waveTimer = 0;
  }
  if (Math.random() < spawnRate && children.length < 40) spawnChild();

  // Update children
  children.forEach(c => {
    c.bobble += 0.15;

    if (c.state === 'wander') {
      c.wanderTimer--;
      if (c.wanderTimer <= 0) {
        if (Math.random() < c.chaseChance && dist(player, c) < 300) {
          c.state = 'chase';
        } else {
          c.dx = (Math.random() - 0.5) * 2;
          c.dy = (Math.random() - 0.5) * 2;
          c.wanderTimer = 60 + Math.random() * 120;
        }
      }
      c.x += c.dx * c.speed * 0.5;
      c.y += c.dy * c.speed * 0.5;
    }
    else if (c.state === 'chase') {
      let angle = Math.atan2(player.y - c.y, player.x - c.x);
      c.dx = Math.cos(angle);
      c.dy = Math.sin(angle);
      c.x += c.dx * c.speed;
      c.y += c.dy * c.speed;
      if (dist(player, c) < 18 && clinging < MAX_CLINGING) {
        c.state = 'clinging';
        clinging++;
        shakeScreen(2);
        spawnParticles(player.x, player.y, c.color, 6, 2);
        if (clinging >= MAX_CLINGING) {
          alive = false;
          shakeScreen(12);
          spawnParticles(player.x, player.y, '#ff4444', 30, 6);
          addMessage('SUBMERGE!', 120);
          let finalScore = state.score + childrenDeposited * 5;
          if (finalScore > highScore) highScore = finalScore;
          textArea.innerHTML = 'Overwhelmed! ' + state.score + 's survived, ' + childrenDeposited + ' deposited.<br>Score: ' + finalScore + (highScore > 0 ? ' (Best: ' + highScore + ')' : '') + '<br>Click to try again.';
          canvas.addEventListener('click', function restart() {
            canvas.removeEventListener('click', restart);
            initGame();
            textArea.textContent = '';
          }, { once: true });
        }
      }
    }
    else if (c.state === 'clinging') {
      let angle = Math.atan2(c.y - player.y, c.x - player.x);
      let targetDist = 14 + c.size;
      c.x += (player.x + Math.cos(angle + Math.sin(c.bobble) * 0.3) * targetDist - c.x) * 0.15;
      c.y += (player.y + Math.sin(angle + Math.sin(c.bobble) * 0.3) * targetDist - c.y) * 0.15;
    }
    else if (c.state === 'fleeing') {
      c.x += c.dx; c.y += c.dy;
      c.dx *= 0.96; c.dy *= 0.96;
      c.wanderTimer--;
      if (c.wanderTimer <= 0) { c.state = 'wander'; c.wanderTimer = 60 + Math.random() * 60; }
    }
    else if (c.state === 'deposited') {
      c.x += Math.sin(c.bobble * 0.5) * 0.3;
    }

    // Boundary wrap
    if (c.state !== 'clinging' && c.state !== 'deposited') {
      if (c.x < -30) c.x = canvas.width + 20;
      if (c.x > canvas.width + 30) c.x = -20;
      if (c.y < -30) c.y = canvas.height + 20;
      if (c.y > canvas.height + 30) c.y = -20;
    }
  });

  // Drop zone deposit
  if (clinging > 0) {
    dropZones.forEach(zone => {
      if (dist(player, zone) < DROP_ZONE_RADIUS) {
        let deposited = 0;
        children.forEach(c => {
          if (c.state === 'clinging') {
            c.state = 'deposited';
            c.x = zone.x + (Math.random() - 0.5) * 30;
            c.y = zone.y + (Math.random() - 0.5) * 30;
            deposited++;
            childrenDeposited++;
            spawnParticles(c.x, c.y, '#88ff88', 8, 3);
          }
        });
        if (deposited > 0) {
          clinging = 0;
          addMessage('+' + deposited + ' deposes!', 45);
          player.energy = Math.min(player.maxEnergy, player.energy + deposited * 8);
        }
      }
    });
  }

  messages.forEach(m => m.life--);
  messages = messages.filter(m => m.life > 0);
}

function drawChild(c) {
  let bob = Math.sin(c.bobble) * 2;
  ctx.fillStyle = c.color;
  ctx.beginPath();
  ctx.arc(c.x, c.y + bob, c.size, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ffe0c0';
  ctx.beginPath();
  ctx.arc(c.x, c.y - c.size + bob, c.size * 0.55, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#333';
  ctx.fillRect(c.x - 2, c.y - c.size - 1 + bob, 1.5, 1.5);
  ctx.fillRect(c.x + 1, c.y - c.size - 1 + bob, 1.5, 1.5);
  if (c.state === 'chase') {
    ctx.fillStyle = '#ff4444';
    ctx.font = '8px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('!', c.x, c.y - c.size - 6 + bob);
  }
  if (c.state === 'deposited') {
    ctx.fillStyle = '#88ff88';
    ctx.font = '8px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('~', c.x, c.y - c.size - 6 + bob);
  }
}

function drawPlayer() {
  if (!alive) return;
  let bob = Math.sin(state.tick * 0.08) * 1;
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(player.x, player.y + 12, 10, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#88aa44';
  ctx.beginPath();
  ctx.arc(player.x, player.y + bob, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ffe0c0';
  ctx.beginPath();
  ctx.arc(player.x, player.y - 12 + bob, 7, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#333';
  ctx.fillRect(player.x - 3, player.y - 13 + bob, 2, 1);
  ctx.fillRect(player.x + 1, player.y - 13 + bob, 2, 1);
  if (clinging > 0) {
    ctx.fillStyle = clinging >= 4 ? '#ff4444' : clinging >= 2 ? '#ffaa44' : '#cccc44';
    ctx.font = '10px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(clinging >= 4 ? '!!!' : clinging >= 2 ? '!!' : '!', player.x, player.y - 22 + bob);
  }
}

function drawDropZone(zone) {
  let pulse = 0.6 + Math.sin(state.tick * 0.05) * 0.15;
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = zone.color;
  ctx.beginPath();
  ctx.arc(zone.x, zone.y, DROP_ZONE_RADIUS * pulse, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 0.6;
  ctx.strokeStyle = zone.color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(zone.x, zone.y, DROP_ZONE_RADIUS, 0, Math.PI * 2);
  ctx.stroke();
  ctx.globalAlpha = 1;
  ctx.fillStyle = zone.color;
  ctx.font = '9px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText(zone.label, zone.x, zone.y + DROP_ZONE_RADIUS + 12);
}

function drawUI() {
  let barW = 120, barH = 8, bx = 10, by = 30;
  ctx.fillStyle = '#333';
  ctx.fillRect(bx, by, barW, barH);
  let energyPct = player.energy / player.maxEnergy;
  ctx.fillStyle = energyPct > 0.5 ? '#88cc44' : energyPct > 0.25 ? '#ccaa44' : '#cc4444';
  ctx.fillRect(bx, by, barW * energyPct, barH);
  ctx.strokeStyle = '#555';
  ctx.strokeRect(bx, by, barW, barH);
  ctx.fillStyle = '#cca';
  ctx.font = '12px Courier New';
  ctx.textAlign = 'left';
  ctx.fillText('Accroches: ' + clinging + '/' + MAX_CLINGING, 10, 55);
  let freeKids = children.filter(c => c.state !== 'deposited' && c.state !== 'clinging').length;
  ctx.fillText('En liberte: ' + freeKids, 10, 70);
  ui.innerHTML = 'Temps: ' + state.score + 's | Deposes: ' + childrenDeposited;
  messages.forEach((m, i) => {
    ctx.globalAlpha = m.life / m.maxLife;
    ctx.fillStyle = '#ffcc44';
    ctx.font = 'bold 16px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(m.text, canvas.width / 2, canvas.height / 2 - 40 - i * 20);
  });
  ctx.globalAlpha = 1;
}

function drawBackground() {
  ctx.fillStyle = '#1a2a1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#223322';
  for (let i = 0; i < 80; i++) {
    ctx.fillRect((i * 97) % canvas.width, (i * 131) % canvas.height, 2, 2);
  }
  ctx.strokeStyle = '#2a3a2a';
  ctx.lineWidth = 20;
  ctx.beginPath();
  ctx.moveTo(0, canvas.height / 2);
  ctx.lineTo(canvas.width, canvas.height / 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(canvas.width / 2, 0);
  ctx.lineTo(canvas.width / 2, canvas.height);
  ctx.stroke();
}

function drawGame() {
  drawBackground();
  drawParticles();
  dropZones.forEach(drawDropZone);
  children.filter(c => c.state === 'deposited').forEach(drawChild);
  children.filter(c => c.state !== 'deposited').forEach(drawChild);
  drawPlayer();
  drawUI();
}

initGame();

function startGame() {
  state.phase = 'playing';
  document.getElementById('title').style.display = 'none';
  canvas.style.display = 'block';
  ui.style.display = 'block';
  textArea.style.display = 'block';
  initGame();
  gameLoop();
}

function gameLoop() {
  if (state.phase !== 'playing') return;
  state.tick++;
  updateGame();
  updateParticles();
  let sx = screenShake ? (Math.random() - 0.5) * screenShake : 0;
  let sy = screenShake ? (Math.random() - 0.5) * screenShake : 0;
  ctx.save();
  ctx.translate(sx, sy);
  drawGame();
  ctx.restore();
  requestAnimationFrame(gameLoop);
}
</script>
</body>
</html>
