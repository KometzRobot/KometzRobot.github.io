<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Meridian Game Jam</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a0f; overflow: hidden; touch-action: none; }
  canvas { display: block; image-rendering: pixelated; }
  #ui {
    position: absolute; top: 10px; left: 10px;
    color: #00ff41; font-family: monospace; font-size: 14px;
    text-shadow: 0 0 4px #00ff4180;
  }
  #start-screen {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: #0a0a0f; color: #00ff41; font-family: monospace; z-index: 10;
  }
  #start-screen h1 { font-size: 36px; margin-bottom: 20px; text-shadow: 0 0 10px #00ff4160; }
  #start-screen p { color: #666; margin-bottom: 30px; }
  #start-screen .btn {
    background: none; border: 1px solid #00ff41; color: #00ff41;
    padding: 12px 40px; font-family: monospace; font-size: 18px; cursor: pointer;
  }
  #start-screen .btn:hover { background: #00ff4120; }
  .hidden { display: none !important; }
</style>
</head>
<body>

<div id="start-screen">
  <h1>GAME TITLE</h1>
  <p>A Meridian Game Jam Entry</p>
  <button class="btn" onclick="startGame()">START</button>
</div>

<canvas id="c"></canvas>
<div id="ui">
  <span id="score">0</span>
</div>

<script>
// === MERIDIAN GAME JAM TEMPLATE ===
// Minimal canvas framework: rendering, input, collision, mobile touch

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const TILE = 16;  // tile size in pixels
const SCALE = 3;  // pixel scale

// Resize
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// === INPUT ===
const keys = {};
window.addEventListener('keydown', e => { keys[e.key] = true; e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key] = false; });

// Mobile touch
const touch = { x: 0, y: 0, active: false, dx: 0, dy: 0 };
canvas.addEventListener('touchstart', e => {
  const t = e.touches[0];
  touch.x = t.clientX; touch.y = t.clientY;
  touch.active = true;
  e.preventDefault();
});
canvas.addEventListener('touchmove', e => {
  if (!touch.active) return;
  const t = e.touches[0];
  touch.dx = t.clientX - touch.x;
  touch.dy = t.clientY - touch.y;
  e.preventDefault();
});
canvas.addEventListener('touchend', e => {
  touch.active = false; touch.dx = 0; touch.dy = 0;
});

// === GAME STATE ===
let state = 'start';  // start, play, gameover
let score = 0;
let frame = 0;

// Player
const player = {
  x: 100, y: 100,
  w: TILE * SCALE, h: TILE * SCALE,
  speed: 3,
  color: '#00ff41'
};

// Simple entities list
let entities = [];

// === COLLISION ===
function collides(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}

// === UPDATE ===
function update() {
  if (state !== 'play') return;
  frame++;

  // Player movement
  let dx = 0, dy = 0;
  if (keys['ArrowLeft'] || keys['a']) dx = -1;
  if (keys['ArrowRight'] || keys['d']) dx = 1;
  if (keys['ArrowUp'] || keys['w']) dy = -1;
  if (keys['ArrowDown'] || keys['s']) dy = 1;

  // Mobile touch controls
  if (touch.active) {
    const threshold = 20;
    if (Math.abs(touch.dx) > threshold) dx = Math.sign(touch.dx);
    if (Math.abs(touch.dy) > threshold) dy = Math.sign(touch.dy);
  }

  // Normalize diagonal
  if (dx !== 0 && dy !== 0) {
    dx *= 0.707; dy *= 0.707;
  }

  player.x += dx * player.speed;
  player.y += dy * player.speed;

  // Keep in bounds
  player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));
  player.y = Math.max(0, Math.min(canvas.height - player.h, player.y));

  // Update entities
  for (let i = entities.length - 1; i >= 0; i--) {
    const e = entities[i];
    if (e.update) e.update(e);
    if (e.dead) entities.splice(i, 1);

    // Check collision with player
    if (!e.dead && collides(player, e)) {
      if (e.onCollide) e.onCollide(e);
    }
  }

  // Spawn logic — customize per game
  if (frame % 60 === 0) {
    spawnEntity();
  }
}

// === SPAWN — customize this ===
function spawnEntity() {
  const e = {
    x: Math.random() * (canvas.width - TILE * SCALE),
    y: -TILE * SCALE,
    w: TILE * SCALE, h: TILE * SCALE,
    speed: 1 + Math.random() * 2,
    color: '#ff9800',
    dead: false,
    update(self) {
      self.y += self.speed;
      if (self.y > canvas.height) self.dead = true;
    },
    onCollide(self) {
      score += 10;
      self.dead = true;
    }
  };
  entities.push(e);
}

// === DRAW ===
function draw() {
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (state === 'play') {
    // Draw player
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.w, player.h);

    // Glow effect
    ctx.shadowColor = player.color;
    ctx.shadowBlur = 8;
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.shadowBlur = 0;

    // Draw entities
    for (const e of entities) {
      ctx.fillStyle = e.color;
      ctx.fillRect(e.x, e.y, e.w, e.h);
    }

    // UI
    document.getElementById('score').textContent = `SCORE: ${score}`;
  }
}

// === GAME LOOP ===
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

function startGame() {
  document.getElementById('start-screen').classList.add('hidden');
  state = 'play';
  score = 0;
  frame = 0;
  entities = [];
  player.x = canvas.width / 2;
  player.y = canvas.height - 100;
}

// Start render loop (stays on start screen until button clicked)
gameLoop();
</script>
</body>
</html>
